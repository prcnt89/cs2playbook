<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Counter-Strike 2 Playbook</title>
  <style>
@font-face {
  font-family: "RobotoCustom";
  src: url("fonts/Roboto-Light.ttf") format("truetype");
  font-weight: 300;
  font-style: normal;
}

@font-face {
  font-family: "RobotoCustom";
  src: url("fonts/Roboto-Medium.ttf") format("truetype");
  font-weight: 700;
  font-style: normal;
}

button,
input,
select,
textarea {
  font-family: "RobotoCustom", sans-serif !important;
  font-weight: 300;
}

button b,
button strong {
  font-weight: 700;
}

body {
  font-family: "RobotoCustom", sans-serif;
  font-weight: 300;
  margin: 0;
  background: #111;
  color: #eee;
}

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .map-tabs,
    .team-tabs {
      display: flex;
      background: #222;
      border-bottom: 1px solid #333;
    }

    .map-tab,
    .team-tab {
      padding: 8px 14px;
      cursor: pointer;
      user-select: none;
      border-right: 1px solid #333;
      font-size: 14px;
    }

    .map-tab.active,
    .team-tab.active {
      background: #444;
      font-weight: bold;
    }

    .main {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 10px;
      box-sizing: border-box;
      overflow: auto;
    }

    .layout {
      display: grid;
      grid-template-columns: 220px 830px 260px;
      grid-template-rows: auto;
      column-gap: 10px;
      align-items: flex-start;
    }

    .menu {
      background: #1b1b1b;
      border: 1px solid #333;
      padding: 8px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }

    .menu button {
      width: 100%;
      margin-bottom: 6px;
      padding: 6px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      cursor: pointer;
      font-size: 13px;
    }

    .menu button:hover {
      background: #444;
    }

    .saved-tactics {
      background: #1b1b1b;
      border: 1px solid #333;
      padding: 8px;
      box-sizing: border-box;
      height: 211px;
      overflow-y: auto;
    }

    .saved-tactics h3,
    .notes h3,
    .menu h3 {
      margin-top: 0;
      font-size: 14px;
      border-bottom: 1px solid #333;
      padding-bottom: 4px;
      text-align: center;
    }

    .tactic-item {
      padding: 4px 6px;
      margin-bottom: 4px;
      background: #262626;
      cursor: pointer;
      font-size: 13px;
    }

    .tactic-item.active {
      background: #3b3b3b;
      font-weight: bold;
    }

    .tactic-item:hover {
      background: #333;
    }

    .notes {
      background: #1b1b1b;
      border: 1px solid #333;
      padding: 8px;
      box-sizing: border-box;
      height: 830px;
      display: flex;
      flex-direction: column;
    }

    .notes textarea {
      flex: 1;
      width: 100%;
      resize: none;
      background: #111;
      color: #eee;
      border: 1px solid #333;
      padding: 6px;
      box-sizing: border-box;
      font-size: 13px;
    }

    .overviews {
      display: flex;
      flex-direction: column;
      align-items: center;
      row-gap: 10px;
    }

    .overview-container {
      position: relative;
      width: 830px;
      height: 830px;
      border: 1px solid #333;
      background: #000;
      overflow: hidden;
    }

    .overview-img {
      width: 830px;
      height: 830px;
      display: block;
    }

    .players-layer {
      position: absolute;
      left: 0;
      top: 0;
      width: 830px;
      height: 830px;
      pointer-events: none;
    }

    .player {
      position: absolute;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      border: 1px solid #fff;
      transform: translate(-50%, -50%);
      cursor: pointer;
      pointer-events: auto;
    }

    .overview-svg {
      position: absolute;
      left: 0;
      top: 0;
      width: 830px;
      height: 830px;
      pointer-events: none;
    }

    .player-menu {
      position: absolute;
      background: #222;
      border: 1px solid #555;
      padding: 4px 0;
      font-size: 13px;
      z-index: 10;
    }

    .player-menu-item {
      padding: 4px 10px;
      cursor: pointer;
      white-space: nowrap;
    }

    .player-menu-item:hover {
      background: #444;
    }

    .play-menu {
      background: #1b1b1b;
      border: 1px solid #333;
      padding: 8px;
      margin-top: 10px;
      text-align: center;
    }

    .play-menu button {
      width: 100%;
      margin-bottom: 6px;
      padding: 6px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      cursor: pointer;
      font-size: 13px;
    }

    .play-menu button:hover {
      background: #444;
    }

    .players-layer-bottom {
      position: absolute;
      left: 0;
      top: 0;
      width: 830px;
      height: 830px;
      pointer-events: none;
    }

    .player-bottom {
      position: absolute;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      border: 1px solid #fff;
      transform: translate(-50%, -50%);
    }

    #statsDisplay {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
    }

    @keyframes bombBlink {
      0%   { box-shadow: 0 0 4px 2px rgba(255,0,0,0.8); }
      50%  { box-shadow: 0 0 10px 4px rgba(255,0,0,1); }
      100% { box-shadow: 0 0 4px 2px rgba(255,0,0,0.8); }
    }
  </style>
</head>
<body>
  <div class="app">

    <!-- Map Tabs -->
    <div class="map-tabs" id="mapTabs"></div>

    <!-- Team Tabs -->
    <div class="team-tabs" id="teamTabs"></div>

    <!-- Main Layout -->
    <div class="main">
      <div class="layout">

        <!-- LEFT COLUMN -->
        <div>

          <!-- Playbook Import/Export MenÃ¼ -->
          <div class="menu">
            <h3>Menu</h3>
            <button id="btnImportPlaybook">Import Playbook (JSON)</button>
            <button id="btnExportPlaybook">Export Playbook (JSON)</button>
            <button id="btnImportTactic">Import tactic (JSON)</button>
            <button id="btnExportTactic">Export tactic (JSON)</button>

            <div style="height: 25px;"></div>

            <button id="btnNew">Create new tactic</button>
            <button id="btnSave">Save tactic...</button>
            <button id="btnDelete">Delete current tactic</button>
            <button id="btnUndo">Undo</button>
          </div>

          <!-- Statistics -->
          <div class="menu" id="statsMenu" style="text-align:center;">
            <h3>Real Statistics</h3>
            <button id="btnWin">Round won (+)</button>
            <button id="btnWinMinus">Round won (-)</button>

            <div style="margin-top: 5px;"></div>

            <button id="btnLoss">Round lost (+)</button>
            <button id="btnLossMinus">Round lost (-)</button>

            <div id="statsDisplay" style="margin-top:8px; font-size:14px;">
              Wins: 0 | Losses: 0<br>
              0% successful
            </div>
          </div>

          <!-- Saved Tactics -->
          <div class="saved-tactics" style="text-align:center;">
            <h3>Saved Tactics</h3>
            <div id="savedTacticsList"></div>
          </div>

          <!-- Round Time + Play/Stop MenÃ¼ -->
<div style="margin-top:12px;">

  <!-- MATCHINFOS als eigenes MenÃ¼ -->
<div class="menu" style="text-align:center;">
  <h3>Matchinfos</h3>

  <div style="font-size:14px; margin-bottom:6px;">Round time:</div>
  <div id="roundTimeDisplay" style="
    font-size:18px;
    font-weight:bold;
    margin-bottom:10px;
    text-align:center;
  ">1:55</div>

  <div style="font-size:14px; margin:10px 0 6px 0;">Duration:</div>
  <div id="durationDisplay" style="
    font-size:18px;
    font-weight:bold;
    margin-bottom:10px;
    text-align:center;
  ">0:00</div>

  <!-- Score jetzt im gleichen Kasten -->
  <div style="font-size:14px; margin:10px 0 6px 0;">Score:</div>
  <div id="scoreDisplay" style="
    font-size:18px;
    font-weight:bold;
    margin-bottom:10px;
    text-align:center;
    display:flex;
    justify-content:center;
    gap:6px;
  ">
    <span id="scoreT" style="color:#f9a03f;">0</span>
    :
    <span id="scoreCT" style="color:#4fa3ff;">0</span>
  </div>

<div id="tacticInfoDisplay" style="
    font-size:14px;
    margin-top:10px;
    white-space:pre-line;
    text-align:center;
    line-height:1.4;
">
Your tactic:
<span id="yourTacticName" style="font-weight:700;"></span>

Enemy tactic:
<span id="enemyTacticName" style="font-weight:700;"></span>
</div>
</div>

            <!-- Play/Stop MenÃ¼ -->
            <div class="play-menu">
              <button id="btnPlay">Simulate</button>
              <button id="btnPlayVs">Simulate (with Enemy)</button>
              <button id="btnPause">Pause / Continue</button>
              <button id="btnStop">Reset</button>
            </div>

          </div>

        </div>

        <!-- CENTER COLUMN -->
        <div class="overviews">

          <!-- Oberes Overview -->
          <div class="overview-container" id="overviewTop">
            <img id="overviewTopImg" class="overview-img" src="" alt="Tactic Overview">
            <svg id="overviewSvg" class="overview-svg"></svg>
            <div id="playersLayer" class="players-layer"></div>
          </div>

          <!-- Unteres Overview -->
          <div class="overview-container" id="overviewBottom">
            <img id="overviewBottomImg" class="overview-img" src="" alt="Simulation Overview">
            <div id="playersLayerBottom" class="players-layer-bottom"></div>
          </div>

        </div>

        <!-- RIGHT COLUMN -->
        <div class="notes">
          <h3>Notes</h3>
          <textarea id="notesArea"></textarea>
        </div>

      </div>
    </div>

  </div>

<script>
/* -------------------------------------------------------
   CONSTANTS & BASIC CONFIGURATION
------------------------------------------------------- */

const maps = ['Ancient', 'Anubis', 'Dust2', 'Inferno', 'Mirage', 'Nuke', 'Overpass', 'Train'];
const teams = ['T', 'CT'];

const spawnZones = {
  Dust2:   { T:{x:239,y:727,width:151,height:45}, CT:{x:479,y:143,width:59,height:56} },
  Ancient: { T:{x:366,y:700,width:69,height:40}, CT:{x:380,y:87,width:78,height:51} },
  Anubis:  { T:{x:333,y:731,width:138,height:32}, CT:{x:305,y:171,width:94,height:38} },
  Inferno: { T:{x:66,y:540,width:35,height:57}, CT:{x:723,y:242,width:31,height:84} },
  Mirage:  { T:{x:704,y:268,width:46,height:71}, CT:{x:243,y:534,width:36,height:81} },
  Nuke:    { T:{x:121,y:243,width:64,height:27}, CT:{x:625,y:177,width:78,height:20} },
  Overpass:{ T:{x:535,y:741,width:33,height:44}, CT:{x:379,y:137,width:47,height:27} },
  Train:   { T:{x:78,y:125,width:68,height:35}, CT:{x:723,y:625,width:54,height:88} }
};

const playerColors = [
  { name: 'Orange', rgb: 'rgb(237,163,56)' },
  { name: 'Green',  rgb: 'rgb(16,152,86)' },
  { name: 'Blue',   rgb: 'rgb(104,163,229)' },
  { name: 'Yellow', rgb: 'rgb(230,241,61)' },
  { name: 'Purple', rgb: 'rgb(128,60,161)' }
];

const SPEED_RUSH = 40;
const SPEED_WALK = 22;
const SPEED_UTILITY = 110;

/* -------------------------------------------------------
   MAP SPEED MULTIPLIERS
------------------------------------------------------- */

const mapSpeedMultiplier = {
  Ancient: 1.00,
  Anubis: 1.00,
  Dust2: 1.20,
  Inferno: 1.20,
  Mirage: 1.00,
  Nuke: 0.80,
  Overpass: 1.00,
  Train: 1.10
};

/* -------------------------------------------------------
   VISION MASKS & SHOOTING
------------------------------------------------------- */

// Offscreen canvas for current map mask
let maskCanvas = document.createElement('canvas');
let maskCtx = maskCanvas.getContext('2d');
let maskImageData = null;
let currentMaskMap = null;

// Shooting config
const SHOOT_INTERVAL = 0.12;   // seconds
const HIT_PROBABILITY = 0.6;   // 60%
const DAMAGE_PER_HIT = 35;     // HP
const STARTING_HP = 100;

// Active smoke clouds (each has x, y, radius, endTime)
let activeSmokes = [];

// Active flash effects: { player, endTime }
let activeFlashes = [];

// Active molotov fires: { x, y, radius, endTime }
let activeMolotovs = [];

// Load mask for a given map (graphics/<map>_mask.png)
function loadMaskForMap(mapName, callback) {
  if (currentMaskMap === mapName && maskImageData) {
    // Already loaded
    callback();
    return;
  }

  const img = new Image();
  img.src = `./graphics/${mapName}_mask.png`;
  img.onload = () => {
    maskCanvas.width = img.width;
    maskCanvas.height = img.height;
    maskCtx.drawImage(img, 0, 0);
    maskImageData = maskCtx.getImageData(0, 0, img.width, img.height);
    currentMaskMap = mapName;
    callback();
  };
  img.onerror = () => {
    console.warn("Could not load mask for map:", mapName);
    maskImageData = null;
    currentMaskMap = null;
    callback();
  };
}

// Get brightness (0â€“255) at map coordinate (x,y) from mask
function getMaskBrightness(x, y) {
  if (!maskImageData) return 255; // treat as fully visible if no mask

  const w = maskImageData.width;
  const h = maskImageData.height;

  const ix = Math.floor(x);
  const iy = Math.floor(y);

  if (ix < 0 || iy < 0 || ix >= w || iy >= h) return 0;

  const idx = (iy * w + ix) * 4;
  const r = maskImageData.data[idx];
  const g = maskImageData.data[idx + 1];
  const b = maskImageData.data[idx + 2];

  // simple luminance
  return 0.299 * r + 0.587 * g + 0.114 * b;
}

// -------------------------------------------------------
// SNAP PLAYER OR PATH POINT TO NEAREST WHITE PIXEL
// -------------------------------------------------------
function snapToNearestWhite(x, y) {
  if (!maskImageData) return { x, y };

  const maxRadius = 25; // smooth & performant

  for (let r = 0; r <= maxRadius; r++) {
    for (let dx = -r; dx <= r; dx++) {
      for (let dy = -r; dy <= r; dy++) {
        const nx = x + dx;
        const ny = y + dy;

        // Skip out-of-bounds
        if (nx < 0 || ny < 0 || nx >= 830 || ny >= 830) continue;

        if (getMaskBrightness(nx, ny) > 30) {
          return { x: nx, y: ny };
        }
      }
    }
  }

  return { x, y };
}

// Check line of sight between two positions using mask
// white = visible, black = walls
function hasLineOfSight(x1, y1, x2, y2) {
  if (!maskImageData) return true;

  const steps = 40;
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const x = x1 + (x2 - x1) * t;
    const y = y1 + (y2 - y1) * t;

    // Smoke blocks vision
    if (isInsideSmoke(x, y)) {
      return false;
    }

    const brightness = getMaskBrightness(x, y);
    if (brightness < 30) {
      return false;
    }
  }
  return true;
}

/* -------------------------------------------------------
   PATHFINDING GRID (166Ã—166) + A*
------------------------------------------------------- */

const GRID_SIZE = 166;          // 166Ã—166 grid
const CELL_SIZE = 830 / GRID_SIZE; // â‰ˆ 5px per cell
let walkGrid = null;

// Build walkability grid from mask
function buildWalkabilityGrid() {
  if (!maskImageData) return;

  walkGrid = new Array(GRID_SIZE);
  for (let y = 0; y < GRID_SIZE; y++) {
    walkGrid[y] = new Array(GRID_SIZE);
    for (let x = 0; x < GRID_SIZE; x++) {

      const px = Math.floor(x * CELL_SIZE);
      const py = Math.floor(y * CELL_SIZE);
      const brightness = getMaskBrightness(px, py);

      walkGrid[y][x] = brightness > 30 ? 1 : 0;
    }
  }

  // -----------------------------------------
  // WALL PADDING (1 cell thick)
  // -----------------------------------------
  const PAD = 1;
  const padded = JSON.parse(JSON.stringify(walkGrid));

  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (walkGrid[y][x] === 0) {
        for (let dy = -PAD; dy <= PAD; dy++) {
          for (let dx = -PAD; dx <= PAD; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < GRID_SIZE && ny < GRID_SIZE) {
              padded[ny][nx] = 0;
            }
          }
        }
      }
    }
  }

  walkGrid = padded;
}

// Convert world â†’ grid
function worldToGrid(x, y) {
  return {
    gx: Math.floor(x / CELL_SIZE),
    gy: Math.floor(y / CELL_SIZE)
  };
}

// Convert grid â†’ world
function gridToWorld(gx, gy) {
  return {
    x: gx * CELL_SIZE + CELL_SIZE / 2,
    y: gy * CELL_SIZE + CELL_SIZE / 2
  };
}

// A* pathfinding
function findPathAStar(start, goal) {
  if (!walkGrid) return null;

  const open = [];
  const closed = new Set();
  const cameFrom = {};

  function hash(x, y) { return x + "," + y; }

  const gScore = {};
  const fScore = {};

  const startKey = hash(start.gx, start.gy);
  gScore[startKey] = 0;
  fScore[startKey] = 0;

  open.push({ gx: start.gx, gy: start.gy, f: 0 });

  // -----------------------------------------
  // Allow diagonals BUT prevent corner cutting
  // -----------------------------------------
  const dirs = [
    [1,0],[-1,0],[0,1],[0,-1],
    [1,1],[1,-1],[-1,1],[-1,-1]
  ];

  while (open.length > 0) {
    open.sort((a,b)=>a.f-b.f);
    const current = open.shift();
    const ck = hash(current.gx, current.gy);

    if (current.gx === goal.gx && current.gy === goal.gy) {
      const path = [];
      let k = ck;
      while (k in cameFrom) {
        const [x,y] = k.split(",").map(Number);
        path.push(gridToWorld(x,y));
        k = cameFrom[k];
      }
      path.reverse();
      return path;
    }

    closed.add(ck);

    for (const [dx,dy] of dirs) {
      const nx = current.gx + dx;
      const ny = current.gy + dy;

      if (nx < 0 || ny < 0 || nx >= GRID_SIZE || ny >= GRID_SIZE) continue;
      if (walkGrid[ny][nx] === 0) continue;

      // Prevent diagonal corner cutting
      if (dx !== 0 && dy !== 0) {
        if (walkGrid[current.gy][current.gx + dx] === 0) continue;
        if (walkGrid[current.gy + dy][current.gx] === 0) continue;
      }

      const nk = hash(nx, ny);
      if (closed.has(nk)) continue;

      const tentative = (gScore[ck] ?? Infinity) + Math.hypot(dx,dy);

      if (!(nk in gScore) || tentative < gScore[nk]) {
        cameFrom[nk] = ck;
        gScore[nk] = tentative;
        fScore[nk] = tentative + Math.hypot(goal.gx - nx, goal.gy - ny);

        if (!open.some(n => n.gx === nx && n.gy === ny)) {
          open.push({ gx:nx, gy:ny, f:fScore[nk] });
        }
      }
    }
  }

  return null;
}

function isInsideSmoke(x, y) {
  const now = performance.now();

  // Remove expired smokes
  activeSmokes = activeSmokes.filter(s => s.endTime > now);

  for (const s of activeSmokes) {
    const dx = x - s.x;
    const dy = y - s.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist <= s.radius) return true;
  }

  return false;
}

function isInsideMolotov(x, y) {
  const now = performance.now();

  // Remove expired molotovs
  activeMolotovs = activeMolotovs.filter(m => m.endTime > now);

  for (const m of activeMolotovs) {
    const dx = x - m.x;
    const dy = y - m.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist <= m.radius) return true;
  }

  return false;
}

function applyGrenadeDamage(g) {
  const radius = 12.5; // HE-Schadensradius = ursprÃ¼nglicher Animationsradius

  state.animation.players.forEach(p => {
    if (!p.alive) return;

    const dx = p.x - g.to.x;
    const dy = p.y - g.to.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist <= radius) {
      const dmg = 50 + Math.floor(Math.random() * 31); // 50â€“80
      p.hp -= dmg;
    }
  });
}

function isFlashed(player) {
  const now = performance.now();

  // Entferne abgelaufene Flash-Effekte
  activeFlashes = activeFlashes.filter(f => f.endTime > now);

  // PrÃ¼fen, ob dieser Spieler geflasht ist
  return activeFlashes.some(f => f.player === player);
}

/* -------------------------------------------------------
   STATE
------------------------------------------------------- */

const state = {
  currentMap: maps[0],
  currentTeam: 'T',
  tabs: {},
  currentAction: null,
  dragging: { active:false, playerId:null, pathId:null },

  animation: {
    running: false,
    players: [],
    frameRequest: null,
    lastTime: null,
    grenades: [],
    shootAccumulator: 0,
    molotovAccumulator: 0,
    checkWin: false
  },

  paused: false,

  roundTimer: {
    interval: null,
    running: false,
    remaining: 115
  },

  durationTimer: {
    interval: null,
    running: false,
    seconds: 0,
    preCountdown: null
  },

  score: { T: 0, CT: 0 },

 bomb: {
    planted: false,
    timer: 40,
    interval: null,
    x: null,
    y: null,
    defuser: null
}
};

/* -------------------------------------------------------
   DOM ELEMENTS
------------------------------------------------------- */

const mapTabsEl = document.getElementById('mapTabs');
const teamTabsEl = document.getElementById('teamTabs');
const overviewTopImg = document.getElementById('overviewTopImg');
const overviewBottomImg = document.getElementById('overviewBottomImg');
const playersLayer = document.getElementById('playersLayer');
const overviewSvg = document.getElementById('overviewSvg');
const notesArea = document.getElementById('notesArea');
// Default notes at start
const defaultNotes =
`Notes...

ðŸ”µ
â€¢ Notes...

ðŸŸ 
â€¢ Notes...

ðŸŸ¢
â€¢ Notes...

ðŸŸ£
â€¢ Notes...

ðŸŸ¡
â€¢ Notes...`;

notesArea.value = defaultNotes;

const savedTacticsList = document.getElementById('savedTacticsList');
const playersLayerBottom = document.getElementById('playersLayerBottom');

const btnNew = document.getElementById('btnNew');
const btnSave = document.getElementById('btnSave');
const btnDelete = document.getElementById('btnDelete');
const btnUndo = document.getElementById('btnUndo');
const btnPlay = document.getElementById('btnPlay');
const btnStop = document.getElementById('btnStop');
const btnPause = document.getElementById('btnPause');
const btnPlayVs = document.getElementById('btnPlayVs');

const btnImportPlaybook = document.getElementById('btnImportPlaybook');
const btnExportPlaybook = document.getElementById('btnExportPlaybook');
const btnImportTactic = document.getElementById('btnImportTactic');
const btnExportTactic = document.getElementById('btnExportTactic');

const roundTimeDisplay = document.getElementById("roundTimeDisplay");
const durationDisplay = document.getElementById("durationDisplay");

let playerMenuEl = null;

/* -------------------------------------------------------
   INITIALIZATION
------------------------------------------------------- */

function initState() {
  // Only initialize if tabs are empty
  if (Object.keys(state.tabs).length > 0) return;

  maps.forEach(map => {
    state.tabs[map] = {};
    teams.forEach(team => {
      state.tabs[map][team] = {
        players: [],
        paths: [],
        notes: '',
        history: [],
        savedTactics: {},
        currentTacticName: null,
        stats: { wins: 0, losses: 0 }
      };
      resetTab(map, team, false);
      pushHistorySnapshot(map, team);
    });
  });
}

function resetTab(map, team, pushHistory = true) {
  const tab = state.tabs[map][team];

  if (pushHistory) {
    pushHistorySnapshot(map, team);
  }

  // Apply reset
  tab.players = createInitialPlayers(map, team);
  tab.paths = [];
  tab.notes = '';
  tab.stats = { wins: 0, losses: 0 };

  if (map === state.currentMap && team === state.currentTeam) {
    renderCurrentTab();
  }
}

function createInitialPlayers(map, team) {
  const zone = spawnZones[map][team];
  const players = [];
  for (let i = 0; i < 5; i++) {
    const x = zone.x + Math.random() * zone.width;
    const y = zone.y + Math.random() * zone.height;
    players.push({
      id: 'p' + i,
      color: playerColors[i].rgb,
      x, y,
      paths: []
    });
  }
  return players;
}

function pushHistorySnapshot(map, team) {
  const tab = state.tabs[map][team];

  const snapshot = JSON.parse(JSON.stringify({
    players: tab.players,
    notes: tab.notes,
    currentTacticName: tab.currentTacticName,
    stats: tab.stats
  }));

  tab.history.push(snapshot);

  if (tab.history.length > 50) {
    tab.history.shift();
  }
}

function undoCurrentTab() {
  const tab = state.tabs[state.currentMap][state.currentTeam];

  if (tab.history.length < 2) return;

  tab.history.pop();

  const last = tab.history[tab.history.length - 1];

  tab.players = JSON.parse(JSON.stringify(last.players));
  tab.notes = last.notes;
  tab.currentTacticName = last.currentTacticName || null;
  tab.stats = last.stats || { wins: 0, losses: 0 };

  renderCurrentTab();
}

/* -------------------------------------------------------
   TABS UI
------------------------------------------------------- */

function initTabsUI() {
  maps.forEach(map => {
    const el = document.createElement('div');
    el.className = 'map-tab';
    el.textContent = map;
    el.dataset.map = map;
    el.addEventListener('click', () => {
      saveNotesToState();
      state.currentMap = map;
      renderTabs();
      renderCurrentTab();
    });
    mapTabsEl.appendChild(el);
  });

  teams.forEach(team => {
    const el = document.createElement('div');
    el.className = 'team-tab';
    el.textContent = team === 'T' ? 'Terrorists' : 'Counter-Terrorists';
    el.dataset.team = team;
    el.addEventListener('click', () => {
      saveNotesToState();
      state.currentTeam = team;
      renderTabs();
      renderCurrentTab();
    });
    teamTabsEl.appendChild(el);
  });

  renderTabs();
}

function renderTabs() {
  [...mapTabsEl.children].forEach(el => {
    el.classList.toggle('active', el.dataset.map === state.currentMap);
  });
  [...teamTabsEl.children].forEach(el => {
    el.classList.toggle('active', el.dataset.team === state.currentTeam);
  });
}

/* -------------------------------------------------------
   RENDERING
------------------------------------------------------- */

function renderCurrentTab() {
  const map = state.currentMap;
  const team = state.currentTeam;
  const tab = state.tabs[map][team];

  const overviewPath = `./graphics/${map}.png`;
  overviewTopImg.src = overviewPath;
  overviewBottomImg.src = overviewPath;

  if (!tab.notes || tab.notes.trim() === '') {
  notesArea.value =
`Notes...

ðŸ”µ
â€¢ Notes...

ðŸŸ 
â€¢ Notes...

ðŸŸ¢
â€¢ Notes...

ðŸŸ£
â€¢ Notes...

ðŸŸ¡
â€¢ Notes...`;
} else {
  notesArea.value = tab.notes;
}

  renderSavedTactics();
  renderPlayersAndPaths();
renderStats();
}

function renderSavedTactics() {
  const tab = state.tabs[state.currentMap][state.currentTeam];
  savedTacticsList.innerHTML = '';
  Object.keys(tab.savedTactics).forEach(name => {
    const item = document.createElement('div');
    item.className = 'tactic-item' + (tab.currentTacticName === name ? ' active' : '');
    item.textContent = name;
    item.dataset.name = name;
    item.addEventListener('click', () => loadTactic(name));
    savedTacticsList.appendChild(item);
  });
}

function renderStats() {
  const tab = state.tabs[state.currentMap][state.currentTeam];
  const stats = tab.stats;

  const wins = stats.wins || 0;
  const losses = stats.losses || 0;
  const total = wins + losses;

  const percent = total > 0 ? Math.round((wins / total) * 100) : 0;

  document.getElementById("statsDisplay").innerHTML =
    `Wins: ${wins} | Losses: ${losses}<br>${percent}% successful`;
}

function updateScoreDisplay() {
  document.getElementById("scoreT").textContent = state.score.T;
  document.getElementById("scoreCT").textContent = state.score.CT;
}

function renderPlayersAndPaths() {
  const tab = state.tabs[state.currentMap][state.currentTeam];

  playersLayer.innerHTML = '';
  overviewSvg.innerHTML = '';

  /* -------------------------------------------------------
     RUSH / WALK PATHS
  ------------------------------------------------------- */
  tab.players.forEach(player => {
    player.paths.forEach(path => {
      if (path.type === 'Rush' || path.type === 'Walk') {
        if (!path.points || path.points.length < 2) return;

        const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        const pointsStr = path.points.map(p => `${p.x},${p.y}`).join(' ');
        poly.setAttribute('points', pointsStr);
        poly.setAttribute('fill', 'none');
        poly.setAttribute('stroke', player.color);
        poly.setAttribute('stroke-width', '2');
        if (path.type === 'Walk') poly.setAttribute('stroke-dasharray', '6,6');
        overviewSvg.appendChild(poly);
      }
    });
  });

/* -------------------------------------------------------
   WAIT (square with seconds, player color + white outline)
------------------------------------------------------- */
tab.players.forEach(player => {
  player.paths.forEach(path => {
    if (path.type === 'Wait') {

      const box = document.createElement('div');
      box.style.position = 'absolute';
      box.style.left = path.x + 'px';
      box.style.top = path.y + 'px';
      box.style.transform = 'translate(-50%, -50%)';
      box.style.width = '18px';
      box.style.height = '18px';
      box.style.borderRadius = '3px';
      box.style.display = 'flex';
      box.style.alignItems = 'center';
      box.style.justifyContent = 'center';
      box.style.pointerEvents = 'auto';
      box.style.fontSize = '11px';
      box.style.fontWeight = 'bold';

      // Player color as background
      box.style.backgroundColor = player.color;

      // White outline
      box.style.border = '1px solid #fff';

      // Automatically determine text color (contrast)
      const rgb = player.color.match(/\d+/g).map(Number);
      const brightness = (rgb[0] * 0.299 + rgb[1] * 0.587 + rgb[2] * 0.114);
      box.style.color = brightness > 150 ? '#000' : '#fff';

      box.textContent = path.seconds;

      box.addEventListener('click', (e) => {
        e.stopPropagation();

        const newSec = parseFloat(prompt("Edit wait time (seconds):", path.seconds));
        if (!isNaN(newSec) && newSec > 0) {
          pushHistorySnapshot(state.currentMap, state.currentTeam);
          path.seconds = newSec;
          renderPlayersAndPaths();
        }
      });

      playersLayer.appendChild(box);
    }
  });
});

  /* -------------------------------------------------------
     GRENADE PATHS (red)
  ------------------------------------------------------- */
  tab.players.forEach(player => {
    player.paths.forEach(path => {
      if (path.type === 'Grenade') {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', path.from.x);
        line.setAttribute('y1', path.from.y);
        line.setAttribute('x2', path.to.x);
        line.setAttribute('y2', path.to.y);
        line.setAttribute('stroke', player.color);
        line.setAttribute('stroke-width', '1');
        line.setAttribute('stroke-dasharray', '4,4');
        overviewSvg.appendChild(line);

        const dot = document.createElement('div');
        dot.style.position = 'absolute';
        dot.style.width = '5px';
        dot.style.height = '5px';
        dot.style.left = path.to.x + 'px';
        dot.style.top = path.to.y + 'px';
        dot.style.transform = 'translate(-50%, -50%)';
        dot.style.backgroundColor = 'red';
        dot.style.borderRadius = '50%';
        playersLayer.appendChild(dot);
      }
    });
  });

  /* -------------------------------------------------------
     FLASHBANG PATHS (white)
  ------------------------------------------------------- */
  tab.players.forEach(player => {
    player.paths.forEach(path => {
      if (path.type === 'Flashbang') {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', path.from.x);
        line.setAttribute('y1', path.from.y);
        line.setAttribute('x2', path.to.x);
        line.setAttribute('y2', path.to.y);
        line.setAttribute('stroke', player.color);
        line.setAttribute('stroke-width', '1');
        line.setAttribute('stroke-dasharray', '4,4');
        overviewSvg.appendChild(line);

        const dot = document.createElement('div');
        dot.style.position = 'absolute';
        dot.style.width = '5px';
        dot.style.height = '5px';
        dot.style.left = path.to.x + 'px';
        dot.style.top = path.to.y + 'px';
        dot.style.transform = 'translate(-50%, -50%)';
        dot.style.backgroundColor = 'white';
        dot.style.borderRadius = '50%';
        playersLayer.appendChild(dot);
      }
    });
  });

  /* -------------------------------------------------------
     SMOKE PATHS (green)
  ------------------------------------------------------- */
  tab.players.forEach(player => {
    player.paths.forEach(path => {
      if (path.type === 'Smoke') {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', path.from.x);
        line.setAttribute('y1', path.from.y);
        line.setAttribute('x2', path.to.x);
        line.setAttribute('y2', path.to.y);
        line.setAttribute('stroke', player.color);
        line.setAttribute('stroke-width', '1');
        line.setAttribute('stroke-dasharray', '4,4');
        overviewSvg.appendChild(line);

        const dot = document.createElement('div');
        dot.style.position = 'absolute';
        dot.style.width = '5px';
        dot.style.height = '5px';
        dot.style.left = path.to.x + 'px';
        dot.style.top = path.to.y + 'px';
        dot.style.transform = 'translate(-50%, -50%)';
        dot.style.backgroundColor = 'green';
        dot.style.borderRadius = '50%';
        playersLayer.appendChild(dot);
      }
    });
  });

  /* -------------------------------------------------------
     MOLOTOV PATHS (orange)
  ------------------------------------------------------- */
  tab.players.forEach(player => {
    player.paths.forEach(path => {
      if (path.type === 'Molotov') {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', path.from.x);
        line.setAttribute('y1', path.from.y);
        line.setAttribute('x2', path.to.x);
        line.setAttribute('y2', path.to.y);
        line.setAttribute('stroke', player.color);
        line.setAttribute('stroke-width', '1');
        line.setAttribute('stroke-dasharray', '4,4');
        overviewSvg.appendChild(line);

        const dot = document.createElement('div');
        dot.style.position = 'absolute';
        dot.style.width = '5px';
        dot.style.height = '5px';
        dot.style.left = path.to.x + 'px';
        dot.style.top = path.to.y + 'px';
        dot.style.transform = 'translate(-50%, -50%)';
        dot.style.backgroundColor = 'orange';
        dot.style.borderRadius = '50%';
        playersLayer.appendChild(dot);
      }
    });
  });

  /* -------------------------------------------------------
     PLANT BOMB (gray rectangle)
  ------------------------------------------------------- */
  tab.players.forEach(player => {
    player.paths.forEach(path => {
      if (path.type === 'PlantBomb') {
        const bomb = document.createElement('div');
        bomb.style.position = 'absolute';
        bomb.style.width = '14px';
        bomb.style.height = '7px';
        bomb.style.left = path.x + 'px';
        bomb.style.top = path.y + 'px';
        bomb.style.transform = 'translate(-50%, -50%)';
        bomb.style.background = '#777';
        bomb.style.border = '1px solid #333';
        playersLayer.appendChild(bomb);
      }
    });
  });

  /* -------------------------------------------------------
     TELEPORT PATHS (light gray)
  ------------------------------------------------------- */
  tab.players.forEach(player => {
    player.paths.forEach(path => {
      if (path.type === 'Teleport') {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', path.from.x);
        line.setAttribute('y1', path.from.y);
        line.setAttribute('x2', path.to.x);
        line.setAttribute('y2', path.to.y);
        line.setAttribute('stroke', '#ccc');
        line.setAttribute('stroke-width', '1');
        line.setAttribute('stroke-dasharray', '4,4');
        overviewSvg.appendChild(line);
      }
    });
  });

  /* -------------------------------------------------------
     PLAYER DOTS
  ------------------------------------------------------- */
  tab.players.forEach(player => {
    const el = document.createElement('div');
    el.className = 'player';
    el.style.backgroundColor = player.color;
    el.style.left = player.x + 'px';
    el.style.top = player.y + 'px';
    el.dataset.id = player.id;

    el.addEventListener('mousedown', onPlayerMouseDown);
    el.addEventListener('click', onPlayerClick);

    playersLayer.appendChild(el);
  });
}

function updateTacticInfoDisplay() {
  const map = state.currentMap;

  // Eigene Taktik
  const myTab = state.tabs[map][state.currentTeam];
  const myName = myTab.currentTacticName || "(no tactic selected)";

  // Gegnerische Taktik (nur bei PlayVs gesetzt)
  let enemyName = state.lastEnemyTacticName || "";

  document.getElementById("yourTacticName").textContent = myName;
  document.getElementById("enemyTacticName").textContent = enemyName;
}

/* -------------------------------------------------------
   NOTES
------------------------------------------------------- */

function saveNotesToState() {
  const tab = state.tabs[state.currentMap][state.currentTeam];
  tab.notes = notesArea.value;
}

notesArea.addEventListener('input', () => {
  const tab = state.tabs[state.currentMap][state.currentTeam];

  const last = tab.history[tab.history.length - 1];
  if (!last || last.notes !== tab.notes) {
    pushHistorySnapshot(state.currentMap, state.currentTeam);
  }

  tab.notes = notesArea.value;
});

/* -------------------------------------------------------
   PLAYER MENU
------------------------------------------------------- */

function showPlayerMenu(playerEl, player) {
  hidePlayerMenu();

  const rect = playerEl.getBoundingClientRect();
  const menu = document.createElement('div');
  menu.className = 'player-menu';

  const actions = [
    'Rush',
    'Walk',
    'Wait',
    'Grenade',
    'Flashbang',
    'Smoke',
    'Molotov',
    ...(state.currentTeam === 'T' ? ['Plant Bomb'] : []),
    'Teleport'
  ];

  actions.forEach(action => {
    const item = document.createElement('div');
    item.className = 'player-menu-item';
    item.textContent = action;
    item.addEventListener('click', () => {
      onPlayerActionSelected(player, action);
      hidePlayerMenu();
    });
    menu.appendChild(item);
  });

/* -----------------------------------------
   REMOVE LAST ACTION
----------------------------------------- */
const removeLastItem = document.createElement('div');
removeLastItem.className = 'player-menu-item';
removeLastItem.textContent = 'Remove last action';
removeLastItem.style.color = '#ff6666';
removeLastItem.addEventListener('click', () => {
  hidePlayerMenu();
  removeLastAction(player);
});
menu.appendChild(removeLastItem);

  /* -----------------------------------------
     RESET PLAYER
  ----------------------------------------- */
  const resetItem = document.createElement('div');
  resetItem.className = 'player-menu-item';
  resetItem.textContent = 'RESET PLAYER';
  resetItem.style.color = '#ff6666';
  resetItem.addEventListener('click', () => {
    hidePlayerMenu();
    resetPlayer(player);
  });
  menu.appendChild(resetItem);

  document.body.appendChild(menu);
  const offsetX = 10;
  const offsetY = 10;
  menu.style.left = (rect.left + offsetX) + 'px';
  menu.style.top = (rect.top + offsetY) + 'px';

  playerMenuEl = menu;
}

function hidePlayerMenu() {
  if (playerMenuEl && playerMenuEl.parentNode) {
    playerMenuEl.parentNode.removeChild(playerMenuEl);
  }
  playerMenuEl = null;
}

function onPlayerClick(e) {
  e.stopPropagation();

  const playerId = e.currentTarget.dataset.id;
  const tab = state.tabs[state.currentMap][state.currentTeam];
  const player = tab.players.find(p => p.id === playerId);
  if (!player) return;

  state.currentAction = null;

  // Remove 1-point ghost path WITHOUT re-rendering
  if (player.paths && player.paths.length > 0) {
    const last = player.paths[player.paths.length - 1];
    if ((last.type === 'Rush' || last.type === 'Walk') &&
        last.points &&
        last.points.length === 1) {

      player.paths.pop();
    }
  }

  // SNAP PLAYER TO NEAREST WHITE PIXEL BEFORE MENU OPENS
  const snapped = snapToNearestWhite(player.x, player.y);
  player.x = snapped.x;
  player.y = snapped.y;

  showPlayerMenu(e.currentTarget, player);
}

function onPlayerActionSelected(player, action) {
  state.currentAction = action;

  // --- WAIT ---
  if (action === 'Wait') {
    const seconds = parseFloat(prompt("Wait time (seconds):"));
    if (isNaN(seconds) || seconds <= 0) return;

    pushHistorySnapshot(state.currentMap, state.currentTeam);

    const waitPath = {
      type: 'Wait',
      seconds: seconds,
      x: player.x,
      y: player.y
    };

    player.paths.push(waitPath);
    renderPlayersAndPaths();
    return;
  }

  // --- GRENADE ---
  if (action === 'Grenade') {
    state.pendingGrenadePlayer = player;
    return;
  }

// --- FLASHBANG ---
if (action === 'Flashbang') {
  state.pendingFlashPlayer = player;
  return;
}

// --- SMOKE ---
if (action === 'Smoke') {
  state.pendingSmokePlayer = player;
  return;
}

// --- MOLOTOV ---
if (action === 'Molotov') {
  state.pendingMolotovPlayer = player;
  return;
}

// --- PLANT BOMB ---
if (action === 'Plant Bomb') {
    pushHistorySnapshot(state.currentMap, state.currentTeam);

    player.paths.push({
        type: 'PlantBomb',
        x: player.x,
        y: player.y
    });

    renderPlayersAndPaths();
    return;
}

// --- TELEPORT ---
if (action === 'Teleport') {
  state.pendingTeleportPlayer = player;
  return;
}

  // Rush/Walk handled in onPlayerMouseDown
}

function removeLastAction(player) {
  const map = state.currentMap;
  const team = state.currentTeam;

  if (!player.paths || player.paths.length === 0) return;

  // Save history snapshot
  pushHistorySnapshot(map, team);

  const last = player.paths[player.paths.length - 1];

  // RUSH / WALK â†’ remove entire path and reset position
  if ((last.type === 'Rush' || last.type === 'Walk') && last.points) {
    const start = last.points[0];
    player.x = start.x;
    player.y = start.y;

    player.paths.pop();

    overviewSvg.innerHTML = '';
    playersLayer.innerHTML = '';
    renderPlayersAndPaths();
    return;
  }

  // TELEPORT â†’ revert to original position
  if (last.type === 'Teleport') {
    if (last.from) {
      player.x = last.from.x;
      player.y = last.from.y;
    }

    player.paths.pop();

    overviewSvg.innerHTML = '';
    playersLayer.innerHTML = '';
    renderPlayersAndPaths();
    return;
  }

  // ALL OTHER ACTIONS â†’ simply remove
  player.paths.pop();

  overviewSvg.innerHTML = '';
  playersLayer.innerHTML = '';
  renderPlayersAndPaths();
}

function resetPlayer(player) {
  if (!confirm("Delete all actions of this player?")) return;

  const map = state.currentMap;
  const team = state.currentTeam;

  pushHistorySnapshot(map, team);

  const zone = spawnZones[map][team];
  player.x = zone.x + Math.random() * zone.width;
  player.y = zone.y + Math.random() * zone.height;
  player.paths = [];

  renderPlayersAndPaths();
}

/* -------------------------------------------------------
   DRAG & PATH
------------------------------------------------------- */

function onPlayerMouseDown(e) {
  e.preventDefault();
  e.stopPropagation();
  hidePlayerMenu();

  const action = state.currentAction;
  if (action !== 'Rush' && action !== 'Walk') return;

  const playerId = e.currentTarget.dataset.id;
  const tab = state.tabs[state.currentMap][state.currentTeam];
  const player = tab.players.find(p => p.id === playerId);
  if (!player) return;

  pushHistorySnapshot(state.currentMap, state.currentTeam);

  state.dragging.active = true;
  state.dragging.playerId = playerId;

  const newPath = {
    type: action,
    points: [{ x: player.x, y: player.y }]
  };
  player.paths.push(newPath);
  state.dragging.pathId = player.paths.length - 1;

  const onMove = (ev) => {
    if (!state.dragging.active) return;

    const rect = overviewTopImg.getBoundingClientRect();
    let x = ev.clientX - rect.left;
    let y = ev.clientY - rect.top;

    // SNAP TO NEAREST WHITE PIXEL
    const snapped = snapToNearestWhite(x, y);
    x = snapped.x;
    y = snapped.y;

    // Update player position
    player.x = Math.max(0, Math.min(830, x));
    player.y = Math.max(0, Math.min(830, y));

    // Add snapped point to path
    const path = player.paths[state.dragging.pathId];
    path.points.push({ x: player.x, y: player.y });

    renderPlayersAndPaths();
  };

  const onUp = () => {
    state.dragging.active = false;
    state.dragging.playerId = null;
    state.dragging.pathId = null;
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('mouseup', onUp);
  };

  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
}

/* -------------------------------------------------------
   SAVED TACTICS
------------------------------------------------------- */

function saveCurrentTactic() {
  const name = prompt('Enter tactic name:');
  if (!name) return;
  const tab = state.tabs[state.currentMap][state.currentTeam];
  const snapshot = JSON.parse(JSON.stringify({
  players: tab.players,
  notes: tab.notes,
  stats: tab.stats
}));
  tab.savedTactics[name] = snapshot;
  tab.currentTacticName = name;
  pushHistorySnapshot(state.currentMap, state.currentTeam);
  renderSavedTactics();
}

function loadTactic(name) {
  const tab = state.tabs[state.currentMap][state.currentTeam];
  const tactic = tab.savedTactics[name];
  if (!tactic) return;
  tab.players = JSON.parse(JSON.stringify(tactic.players));
  tab.notes = tactic.notes;
tab.stats = tactic.stats || { wins: 0, losses: 0 };
  tab.currentTacticName = name;
  pushHistorySnapshot(state.currentMap, state.currentTeam);
  renderCurrentTab();
  updateTacticInfoDisplay();
}

function deleteCurrentTactic() {
  const tab = state.tabs[state.currentMap][state.currentTeam];
  const currentName = tab.currentTacticName;
  if (!currentName) {
    resetTab(state.currentMap, state.currentTeam, true);
    return;
  }
  if (!confirm(`Delete tactic "${currentName}"?`)) return;
  delete tab.savedTactics[currentName];
  tab.currentTacticName = null;
  resetTab(state.currentMap, state.currentTeam, true);
  renderSavedTactics();
}

/* -------------------------------------------------------
   ANIMATION (BOTTOM OVERVIEW)
------------------------------------------------------- */

function buildAnimationState() {
  const tab = state.tabs[state.currentMap][state.currentTeam];
  const animPlayers = [];

  tab.players.forEach(player => {
    const animPaths = player.paths.map(path => {

      // WAIT
      if (path.type === 'Wait') {
        return {
          type: 'Wait',
          seconds: path.seconds,
          x: path.x,
          y: path.y
        };
      }

      // GRENADE / FLASH / SMOKE / MOLOTOV
      if (
        path.type === 'Grenade' ||
        path.type === 'Flashbang' ||
        path.type === 'Smoke' ||
        path.type === 'Molotov'
      ) {
        const dx = path.to.x - path.from.x;
        const dy = path.to.y - path.from.y;
        const length = Math.sqrt(dx*dx + dy*dy);

        return {
          type: path.type,
          from: path.from,
          to: path.to,
          dx, dy,
          length,
          speed: SPEED_UTILITY * mapSpeedMultiplier[state.currentMap],
          progress: 0,
          el: null
        };
      }

      // PLANT BOMB
      if (path.type === 'PlantBomb') {
        return {
          type: 'PlantBomb',
          x: path.x,
          y: path.y,
          progress: 0,
          duration: 3.5, // seconds
          planted: false
        };
      }

      // TELEPORT
      if (path.type === 'Teleport') {
        return {
          type: 'Teleport',
          from: path.from,
          to: path.to
        };
      }

      // RUSH / WALK
      if (path.type === 'Rush' || path.type === 'Walk') {
        const segments = [];
        let totalLength = 0;

        for (let i = 0; i < path.points.length - 1; i++) {
          const a = path.points[i];
          const b = path.points[i + 1];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.sqrt(dx*dx + dy*dy);
          if (len > 0) {
            segments.push({ from: a, to: b, length: len });
            totalLength += len;
          }
        }

        const mult = mapSpeedMultiplier[state.currentMap];

        return {
          type: path.type,
          segments,
          totalLength,
          speed: (path.type === 'Rush' ? SPEED_RUSH : SPEED_WALK) * mult
        };
      }
    });

    const startPos = animPaths[0]?.segments?.[0]?.from || { x: player.x, y: player.y };

    animPlayers.push({
      color: player.color,
      x: startPos.x,
      y: startPos.y,
      paths: animPaths,
      currentPathIndex: 0,
      currentSegmentIndex: 0,
      distanceOnSegment: 0,
      waitRemaining: null,
      done: false,
      el: null,
      isEnemy: false,          // eigenes Team
      hp: STARTING_HP,
      alive: true
    });
  });

  return animPlayers;
}

/* -------------------------------------------------------
   AUTO-RUSH FOR PLAYERS WITH NO ACTIONS
------------------------------------------------------- */

function autoRushIfNoActions(player, enemies) {
  if (!player.alive) return;
  if (!player.done) return;

  // ---------------------------------------------------------
  // CT korrekt erkennen (egal ob ich T oder CT spiele)
  // ---------------------------------------------------------
  const ctTeamIsEnemy = (state.currentTeam === "T");
  const playerIsCT = (player.isEnemy === ctTeamIsEnemy);

  // ---------------------------------------------------------
  // CT sollen defusen, wenn Bombe liegt
  // ---------------------------------------------------------
  const ctShouldDefuse =
    state.animation.checkWin &&
    state.bomb.planted &&
    state.bomb.x !== null &&
    playerIsCT;

  if (ctShouldDefuse) {

    const dx = player.x - state.bomb.x;
    const dy = player.y - state.bomb.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    // ---------------------------------------------------------
    // CT reached bomb â†’ start/continue defuse
    // ---------------------------------------------------------
    if (dist < 12) {

      // Wenn bereits ein Defuser existiert â†’ andere CT NICHT defusen lassen
      if (state.bomb.defuser && state.bomb.defuser !== player) {
        return;
      }

      // Wenn noch kein Defuser existiert â†’ dieser CT wird Defuser
      if (!state.bomb.defuser) {
        state.bomb.defuser = player;
        player.defuseRemaining = 5;
      }

      return;
    }

    // ---------------------------------------------------------
    // CT runs to bomb
    // ---------------------------------------------------------
    const start = worldToGrid(player.x, player.y);
    const goal = worldToGrid(state.bomb.x, state.bomb.y);

    let path = findPathAStar(start, goal);
    if (!path || path.length < 2) return;

    function segmentHitsWall(a, b) {
      const steps = 20;
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = a.x + (b.x - a.x) * t;
        const y = a.y + (b.y - a.y) * t;
        const g = worldToGrid(x, y);
        if (walkGrid[g.gy][g.gx] === 0) return true;
      }
      return false;
    }

    const cleaned = [];
    for (let i = 0; i < path.length - 1; i++) {
      if (!segmentHitsWall(path[i], path[i+1])) {
        cleaned.push(path[i]);
      }
    }
    cleaned.push(path[path.length - 1]);

    if (cleaned.length < 2) return;

    const rushPath = {
      type: "Rush",
      segments: [],
      totalLength: 0,
      speed: SPEED_RUSH * mapSpeedMultiplier[state.currentMap]
    };

    for (let i = 0; i < cleaned.length - 1; i++) {
      const a = cleaned[i];
      const b = cleaned[i+1];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const len = Math.sqrt(dx*dx + dy*dy);
      rushPath.segments.push({ from:a, to:b, length:len });
      rushPath.totalLength += len;
    }

    player.paths.push(rushPath);
    player.currentPathIndex = player.paths.length - 1;
    player.currentSegmentIndex = 0;
    player.distanceOnSegment = 0;
    player.done = false;

    return;
  }

  // ---------------------------------------------------------
  // OLD BEHAVIOR: run to nearest enemy
  // ---------------------------------------------------------
  if (enemies.length === 0) return;

  let nearest = null;
  let bestDist = Infinity;

  enemies.forEach(e => {
    if (!e.alive) return;
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    const d = dx*dx + dy*dy;
    if (d < bestDist) {
      bestDist = d;
      nearest = e;
    }
  });

  if (!nearest) return;

  const start = worldToGrid(player.x, player.y);
  const goal = worldToGrid(nearest.x, nearest.y);

  let path = findPathAStar(start, goal);
  if (!path || path.length < 2) return;

  function segmentHitsWall(a, b) {
    const steps = 20;
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = a.x + (b.x - a.x) * t;
      const y = a.y + (b.y - a.y) * t;
      const g = worldToGrid(x, y);
      if (walkGrid[g.gy][g.gx] === 0) return true;
    }
    return false;
  }

  const cleaned = [];
  for (let i = 0; i < path.length - 1; i++) {
    if (!segmentHitsWall(path[i], path[i+1])) {
      cleaned.push(path[i]);
    }
  }
  cleaned.push(path[path.length - 1]);

  if (cleaned.length < 2) return;

  const rushPath = {
    type: "Rush",
    segments: [],
    totalLength: 0,
    speed: SPEED_RUSH * mapSpeedMultiplier[state.currentMap]
  };

  for (let i = 0; i < cleaned.length - 1; i++) {
    const a = cleaned[i];
    const b = cleaned[i+1];
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const len = Math.sqrt(dx*dx + dy*dy);
    rushPath.segments.push({ from:a, to:b, length:len });
    rushPath.totalLength += len;
  }

  player.paths.push(rushPath);
  player.currentPathIndex = player.paths.length - 1;
  player.currentSegmentIndex = 0;
  player.distanceOnSegment = 0;
  player.done = false;
}

function buildEnemyAnimationState(enemyPlayers) {
  const animPlayers = [];

  enemyPlayers.forEach(player => {
    const animPaths = player.paths.map(path => {
      if (path.type === 'Wait') {
        return {
          type: 'Wait',
          seconds: path.seconds,
          x: path.x,
          y: path.y
        };
      }

      if (
        path.type === 'Grenade' ||
        path.type === 'Flashbang' ||
        path.type === 'Smoke' ||
        path.type === 'Molotov'
      ) {
        const dx = path.to.x - path.from.x;
        const dy = path.to.y - path.from.y;
        const length = Math.sqrt(dx*dx + dy*dy);

        return {
          type: path.type,
          from: path.from,
          to: path.to,
          dx, dy,
          length,
          speed: SPEED_UTILITY * mapSpeedMultiplier[state.currentMap],
          progress: 0,
          el: null
        };
      }

      if (path.type === 'PlantBomb') {
        return {
          type: 'PlantBomb',
          x: path.x,
          y: path.y,
          progress: 0,
          duration: 3.5,
          planted: false
        };
      }

      if (path.type === 'Teleport') {
        return {
          type: 'Teleport',
          from: path.from,
          to: path.to
        };
      }

      if (path.type === 'Rush' || path.type === 'Walk') {
        const segments = [];
        let totalLength = 0;

        for (let i = 0; i < path.points.length - 1; i++) {
          const a = path.points[i];
          const b = path.points[i + 1];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.sqrt(dx*dx + dy*dy);
          if (len > 0) {
            segments.push({ from: a, to: b, length: len });
            totalLength += len;
          }
        }

        const mult = mapSpeedMultiplier[state.currentMap];

        return {
          type: path.type,
          segments,
          totalLength,
          speed: (path.type === 'Rush' ? SPEED_RUSH : SPEED_WALK) * mult
        };
      }
    });

    const startPos = animPaths[0]?.segments?.[0]?.from || { x: player.x, y: player.y };

    animPlayers.push({
      color: "#333",        // dark grey
      x: startPos.x,
      y: startPos.y,
      paths: animPaths,
      currentPathIndex: 0,
      currentSegmentIndex: 0,
      distanceOnSegment: 0,
      waitRemaining: null,
      done: false,
      el: null,
      isEnemy: true,
      hp: STARTING_HP,
      alive: true
    });
  });

  return animPlayers;
}

function startAnimation() {
  stopAnimation();

  const animPlayers = buildAnimationState();
  playersLayerBottom.innerHTML = '';

  animPlayers.forEach(p => {
    const el = document.createElement('div');
    el.className = 'player-bottom';
    el.style.backgroundColor = p.color;
    el.style.left = p.x + 'px';
    el.style.top = p.y + 'px';
    playersLayerBottom.appendChild(el);
    p.el = el;
  });

  state.animation.players = animPlayers;
  state.animation.grenades = [];
  state.animation.running = true;
  state.animation.lastTime = null;
  state.animation.frameRequest = requestAnimationFrame(animationLoop);
}

function stopAnimation() {
  state.animation.running = false;
  if (state.animation.frameRequest != null) {
    cancelAnimationFrame(state.animation.frameRequest);
    state.animation.frameRequest = null;
  }
  playersLayerBottom.innerHTML = '';
}

function addUtilityToAnimation(path) {
  const el = document.createElement('div');
  el.style.position = 'absolute';
  el.style.width = '5px';
  el.style.height = '5px';
  el.style.borderRadius = '50%';

  // Farbe abhÃ¤ngig vom Typ
  if (path.type === 'Grenade') el.style.backgroundColor = 'red';
  if (path.type === 'Flashbang') el.style.backgroundColor = 'white';
  if (path.type === 'Smoke') el.style.backgroundColor = 'green';
  if (path.type === 'Molotov') el.style.backgroundColor = 'orange';

  el.style.left = path.from.x + 'px';
  el.style.top = path.from.y + 'px';

  playersLayerBottom.appendChild(el);

  state.animation.grenades.push({
    el,
    type: path.type,
    from: path.from,
    to: path.to,
    dx: path.dx,
    dy: path.dy,
    length: path.length,
    speed: SPEED_UTILITY,
    progress: 0
  });
}

/* -------------------------------------------------------
   ANIMATION LOOP
------------------------------------------------------- */

function animationLoop(timestamp) {
  if (!state.animation.running) return;

  // Pause handling
  if (state.paused) {
    state.animation.frameRequest = requestAnimationFrame(animationLoop);
    return;
  }

  // Initial timestamp
  if (state.animation.lastTime == null) {
    state.animation.lastTime = timestamp;
    state.animation.frameRequest = requestAnimationFrame(animationLoop);
    return;
  }

  const dtMs = timestamp - state.animation.lastTime;
  const dt = dtMs / 830;
  state.animation.lastTime = timestamp;

  let allPlayersDone = true;

  state.animation.shootAccumulator += dt;
  state.animation.molotovAccumulator += dt;

  /* -------------------------------------------------------
     ANIMATE PLAYERS
  ------------------------------------------------------- */
  state.animation.players.forEach(p => {
    if (!p.alive) return;
    if (p.done || p.paths.length === 0) return;

    let remaining = dt;

    while (remaining > 0 && !p.done) {
      const path = p.paths[p.currentPathIndex];
      if (!path) {
        p.done = true;
        break;
      }

      /* WAIT */
      if (path.type === 'Wait') {
        if (p.waitRemaining == null) p.waitRemaining = path.seconds;

        p.waitRemaining -= remaining;
        p.x = path.x;
        p.y = path.y;

        if (p.waitRemaining <= 0) {
          p.waitRemaining = null;
          p.currentPathIndex++;
        }

        remaining = 0;
        continue;
      }

      /* PLANT BOMB */
if (path.type === 'PlantBomb') {
  p.x = path.x;
  p.y = path.y;

  path.progress += remaining;

  if (path.progress >= path.duration && !path.planted) {
    path.planted = true;

// Save bomb position globally
state.bomb.x = path.x;
state.bomb.y = path.y;

    // Bomb visual
    const bomb = document.createElement('div');
    bomb.style.position = 'absolute';
    bomb.style.width = '14px';
    bomb.style.height = '7px';
    bomb.style.left = path.x + 'px';
    bomb.style.top = path.y + 'px';
    bomb.style.transform = 'translate(-50%, -50%)';
    bomb.style.background = '#777';
    bomb.style.border = '1px solid #333';
    bomb.style.animation = 'bombBlink 0.8s infinite';
    playersLayerBottom.appendChild(bomb);

    // NEW: Start bomb timer ONLY in PlayVs mode
    if (state.animation.checkWin && !state.bomb.planted) {
      state.bomb.planted = true;
      startBombTimer();
    }
  }

  if (path.progress >= path.duration) {
    p.currentPathIndex++;
  }

  remaining = 0;
  continue;
}

      /* UTILITY */
      if (
        path.type === 'Grenade' ||
        path.type === 'Flashbang' ||
        path.type === 'Smoke' ||
        path.type === 'Molotov'
      ) {
        addUtilityToAnimation(path);

        p.currentPathIndex++;

        if (p.currentPathIndex >= p.paths.length) {
          p.done = true;
        }

        remaining = 0;
        continue;
      }

      /* TELEPORT */
      if (path.type === 'Teleport') {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', path.from.x);
        line.setAttribute('y1', path.from.y);
        line.setAttribute('x2', path.to.x);
        line.setAttribute('y2', path.to.y);
        line.setAttribute('stroke', '#ccc');
        line.setAttribute('stroke-width', '1');
        line.setAttribute('stroke-dasharray', '4,4');
        overviewBottom.appendChild(line);

        p.x = path.to.x;
        p.y = path.to.y;

        p.currentPathIndex++;
        if (p.currentPathIndex >= p.paths.length) {
          p.done = true;
        }

        remaining = 0;
        continue;
      }

      /* RUSH / WALK */
      if (path.type === 'Rush' || path.type === 'Walk') {
        if (!path.segments || path.segments.length === 0) {
          p.currentPathIndex++;
          p.currentSegmentIndex = 0;
          p.distanceOnSegment = 0;

          if (p.currentPathIndex >= p.paths.length) {
            p.done = true;
            break;
          }
          continue;
        }

        const seg = path.segments[p.currentSegmentIndex];
        const speed = path.speed;
        const distToTravel = speed * remaining;
        const distLeft = seg.length - p.distanceOnSegment;

        if (distToTravel >= distLeft) {
          p.distanceOnSegment = seg.length;
          p.x = seg.to.x;
          p.y = seg.to.y;

          remaining -= distLeft / speed;

          p.currentSegmentIndex++;
          p.distanceOnSegment = 0;

          if (p.currentSegmentIndex >= path.segments.length) {
            p.currentPathIndex++;
            p.currentSegmentIndex = 0;
            p.distanceOnSegment = 0;

            if (p.currentPathIndex >= p.paths.length) {
              p.done = true;
              break;
            }
          }
        } else {
          p.distanceOnSegment += distToTravel;
          const t = p.distanceOnSegment / seg.length;
          p.x = seg.from.x + (seg.to.x - seg.from.x) * t;
          p.y = seg.from.y + (seg.to.y - seg.from.y) * t;
          remaining = 0;
        }

        continue;
      }

      p.currentPathIndex++;
      if (p.currentPathIndex >= p.paths.length) {
        p.done = true;
        break;
      }
    }

    if (!p.done && p.alive) allPlayersDone = false;

    if (p.el) {
      p.el.style.left = p.x + 'px';
      p.el.style.top = p.y + 'px';
    }
  });

  /* -------------------------------------------------------
     AUTO-RUSH (VS ENEMY ONLY)
  ------------------------------------------------------- */
  if (state.animation.checkWin) {
    state.animation.players.forEach(p => {
      if (p.done && p.alive) {
        const enemies = state.animation.players.filter(e => e.isEnemy !== p.isEnemy && e.alive);
        autoRushIfNoActions(p, enemies);
      }
    });
  }

  /* -------------------------------------------------------
     ANIMATE UTILITIES
  ------------------------------------------------------- */
  state.animation.grenades = state.animation.grenades.filter(g => {
    g.progress += g.speed * dt;

    const t = Math.min(g.progress / g.length, 1);
    const x = g.from.x + g.dx * t;
    const y = g.from.y + g.dy * t;

    g.el.style.left = x + 'px';
    g.el.style.top = y + 'px';

    if (t >= 1) {
      g.el.remove();
      createUtilityExplosion(g);
      return false;
    }
    return true;
  });

  /* -------------------------------------------------------
     SHOOTING
  ------------------------------------------------------- */
  while (state.animation.shootAccumulator >= SHOOT_INTERVAL) {
    state.animation.shootAccumulator -= SHOOT_INTERVAL;
    performShootingStep();
  }

  /* -------------------------------------------------------
     MOLOTOV DAMAGE
  ------------------------------------------------------- */
  while (state.animation.molotovAccumulator >= 1.0) {
    state.animation.molotovAccumulator -= 1.0;

    state.animation.players.forEach(p => {
      if (!p.alive) return;

      if (isInsideMolotov(p.x, p.y)) {
        p.hp -= 40;
      }
    });
  }

  /* -------------------------------------------------------
     REMOVE DEAD PLAYERS
  ------------------------------------------------------- */
  state.animation.players.forEach(p => {
    if (p.alive && p.hp <= 0) {
      p.alive = false;
      p.done = true;
      if (p.el && p.el.parentNode) {
        p.el.parentNode.removeChild(p.el);
      }
    }
  });

  /* -------------------------------------------------------
   WIN CHECK (VS ENEMY ONLY)
------------------------------------------------------- */
if (state.animation.checkWin) {

  if (state.roundTimer.remaining <= 0) {
    return;
  }

  if (checkWinCondition()) {
    state.animation.running = false;
    state.animation.frameRequest = null;

    if (state.roundTimer.interval) clearInterval(state.roundTimer.interval);
    if (state.durationTimer.interval) clearInterval(state.durationTimer.interval);

    return;
  }
}

  /* -------------------------------------------------------
   STOP CONDITION (NORMAL SIMULATE ONLY)
------------------------------------------------------- */
if (!state.animation.checkWin) {
  if (allPlayersDone && state.animation.grenades.length === 0) {

    // Animation stoppen
    state.animation.running = false;
    state.animation.frameRequest = null;

    // Round timer stoppen
    if (state.roundTimer.interval) {
      clearInterval(state.roundTimer.interval);
      state.roundTimer.interval = null;
    }

    // Unified tick stoppen (WICHTIG!)
    if (state.unifiedInterval) {
      clearInterval(state.unifiedInterval);
      state.unifiedInterval = null;
    }

    // Duration timer NICHT weiterlaufen lassen
    if (state.durationTimer.interval) {
      clearInterval(state.durationTimer.interval);
      state.durationTimer.interval = null;
    }

    return;
  }
}

  state.animation.frameRequest = requestAnimationFrame(animationLoop);
}

function performShootingStep() {
  const players = state.animation.players.filter(p => p.alive);

  // -----------------------------------------
  // 1. Treffer sammeln, aber NICHT anwenden
  // -----------------------------------------
  const hits = []; // { shooter, target }

  players.forEach(shooter => {
    const enemies = players.filter(
      t => t.alive && t.isEnemy !== shooter.isEnemy
    );
    if (enemies.length === 0) return;

    const visibleEnemies = enemies.filter(enemy =>
      hasLineOfSight(shooter.x, shooter.y, enemy.x, enemy.y)
    );

    if (visibleEnemies.length === 0) return;

    let target = null;
    let bestDist = Infinity;
    visibleEnemies.forEach(enemy => {
      const dx = enemy.x - shooter.x;
      const dy = enemy.y - shooter.y;
      const dist = dx*dx + dy*dy;
      if (dist < bestDist) {
        bestDist = dist;
        target = enemy;
      }
    });

    if (!target) return;

    const hitChance = isFlashed(shooter) ? 0.10 : HIT_PROBABILITY;

    if (Math.random() < hitChance) {
      hits.push({ shooter, target });
    }
  });

  // -----------------------------------------
  // 2. Gegenseitige Kills verhindern
  // -----------------------------------------
  const finalHits = [];

  hits.forEach(hit => {
    const reverse = hits.find(h =>
      h.shooter === hit.target && h.target === hit.shooter
    );

    if (reverse) {
      // Beide wÃ¼rden sich gegenseitig treffen â†’ nur EIN Treffer zÃ¤hlt
      // Wir nehmen den zuerst gefundenen
      if (!finalHits.includes(reverse) && !finalHits.includes(hit)) {
        finalHits.push(hit); 
      }
    } else {
      finalHits.push(hit);
    }
  });

  // -----------------------------------------
  // 3. Treffer anwenden
  // -----------------------------------------
  finalHits.forEach(hit => {
    hit.target.hp -= DAMAGE_PER_HIT;
  });
}

function checkWinCondition() {
  const aliveMyTeam = state.animation.players.filter(p => p.alive && !p.isEnemy);
  const aliveEnemyTeam = state.animation.players.filter(p => p.alive && p.isEnemy);

  // --- DRAW ---
  if (aliveMyTeam.length === 0 && aliveEnemyTeam.length === 0) {
    stopAllTimers();
    state.animation.running = false;
    alert("Draw!");
    return true;
  }

  // --- IF BOMB IS PLANTED: KILLS DO NOT END THE ROUND ---
  if (state.bomb.planted) {
    // Bombe liegt â†’ nur Defuse oder Explosion entscheidet
    return false;
  }

  // --- IF BOMB IS NOT PLANTED: KILLS DECIDE THE ROUND ---
  if (aliveEnemyTeam.length === 0) {
    stopAllTimers();
    state.animation.running = false;

    state.score[state.currentTeam]++;
    updateScoreDisplay();
    alert("Your team wins!");
    return true;
  }

  if (aliveMyTeam.length === 0) {
    stopAllTimers();
    state.animation.running = false;

    const enemy = state.currentTeam === "T" ? "CT" : "T";
    state.score[enemy]++;
    updateScoreDisplay();
    alert("Enemy team wins!");
    return true;
  }

  return false;
}

function createUtilityExplosion(g) {
  const el = document.createElement('div');
  el.style.position = 'absolute';
  el.style.left = g.to.x + 'px';
  el.style.top = g.to.y + 'px';
  el.style.transform = 'translate(-50%, -50%)';
  el.style.borderRadius = '50%';
  el.style.pointerEvents = 'none';
  el.style.opacity = '1';
  el.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';

  let duration = 600;

  /* -------------------------------------------------------
   FLASHBANG (angepasster Radius)
------------------------------------------------------- */
if (g.type === 'Flashbang') {
  const radius = 50; // ursprÃ¼nglicher Animationsradius
  el.style.width = radius * 2 + 'px';
  el.style.height = radius * 2 + 'px';
  el.style.background = 'rgba(255,255,255,0.9)';
  duration = 200;

  const now = performance.now();

  state.animation.players.forEach(p => {
    if (!p.alive) return;

    const dx = p.x - g.to.x;
    const dy = p.y - g.to.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist <= radius) {
      activeFlashes.push({
        player: p,
        endTime: now + 3000 // 3 Sekunden Flash
      });
    }
  });
}

  /* -------------------------------------------------------
     SMOKE
  ------------------------------------------------------- */
  if (g.type === 'Smoke') {
  const radius = 30; // ursprÃ¼nglicher Animationsradius
  el.style.width = radius * 2 + 'px';
  el.style.height = radius * 2 + 'px';
  el.style.background = 'rgba(150,150,150,0.7)';
  el.style.filter = 'blur(6px)';
  duration = 18000;

  activeSmokes.push({
    x: g.to.x,
    y: g.to.y,
    radius,
    endTime: performance.now() + duration
  });
}

  /* -------------------------------------------------------
     MOLOTOV
  ------------------------------------------------------- */
  if (g.type === 'Molotov') {
  const radius = 17.5; // ursprÃ¼nglicher Animationsradius
  el.style.width = radius * 2 + 'px';
  el.style.height = radius * 2 + 'px';
  el.style.background = 'radial-gradient(circle, rgba(255,150,0,0.9), rgba(255,0,0,0.6))';
  duration = 7000;

  activeMolotovs.push({
    x: g.to.x,
    y: g.to.y,
    radius,
    endTime: performance.now() + duration
  });
}

  /* -------------------------------------------------------
     HE GRENADE (NEU)
  ------------------------------------------------------- */
  if (g.type === 'Grenade') {
    el.style.width = '25px';
    el.style.height = '25px';
    el.style.background = 'rgba(255,0,0,0.8)';

    // HE-Damage anwenden
    applyGrenadeDamage(g);
  }

  playersLayerBottom.appendChild(el);

  if (g.type === 'Flashbang' || g.type === 'Grenade') {
    requestAnimationFrame(() => {
      el.style.transform = 'translate(-50%, -50%) scale(1.6)';
      el.style.opacity = '0';
    });
  }

  setTimeout(() => el.remove(), duration);
}

/* -------------------------------------------------------
   ROUND TIMER
------------------------------------------------------- */

function resetRoundTimer() {
  // Round timer stoppen
  if (state.roundTimer.interval) {
    clearInterval(state.roundTimer.interval);
    state.roundTimer.interval = null;
  }

  // Unified tick stoppen (WICHTIG!)
  if (state.unifiedInterval) {
    clearInterval(state.unifiedInterval);
    state.unifiedInterval = null;
  }

  // Duration timer zurÃ¼cksetzen
  state.durationTimer.seconds = 0;
  durationDisplay.textContent = "0:00";

  // Round time zurÃ¼cksetzen
  state.roundTimer.remaining = 115;
  roundTimeDisplay.textContent = "1:55";

  // Score zurÃ¼cksetzen
  state.score.T = 0;
  state.score.CT = 0;
  updateScoreDisplay();

  // Bombenstatus zurÃ¼cksetzen
  state.bomb.planted = false;
  state.bomb.timer = 40;

  if (state.bomb.interval) {
    clearInterval(state.bomb.interval);
    state.bomb.interval = null;
  }
}

function startPreCountdown(callback) {
  // Countdown entfernt â†’ sofort starten
  callback();
}

function startDurationPreCountdown(callback) {
  // Countdown entfernt â†’ sofort starten
  callback();
}

function startDurationTimer() {
  // Falls unified tick schon lÃ¤uft â†’ nichts tun
  if (state.unifiedInterval) return;

  // Unified Tick starten
  startUnifiedTick();
}

function startBombTimer() {
  // Round timer stoppen
  if (state.roundTimer.interval) {
    clearInterval(state.roundTimer.interval);
    state.roundTimer.interval = null;
  }

  // Bombenstatus setzen
  state.bomb.planted = true;
  state.bomb.timer = 40;

  // Anzeige sofort aktualisieren
  roundTimeDisplay.textContent = "0:40";

  // Unified Tick starten (falls nicht aktiv)
  startUnifiedTick();
}

function startUnifiedTick() {
  if (state.unifiedInterval) {
    clearInterval(state.unifiedInterval);
  }

  state.unifiedInterval = setInterval(() => {

    // ---------------------------------------------------------
    // DURATION TIMER
    // ---------------------------------------------------------
    state.durationTimer.seconds++;
    const m = Math.floor(state.durationTimer.seconds / 60);
    const s = state.durationTimer.seconds % 60;
    durationDisplay.textContent = `${m}:${s.toString().padStart(2, "0")}`;


    // ---------------------------------------------------------
    // ROUND TIMER (wenn Bombe NICHT liegt)
    // ---------------------------------------------------------
    if (!state.bomb.planted && state.roundTimer.remaining > 0) {

      state.roundTimer.remaining--;

      const rm = Math.floor(state.roundTimer.remaining / 60);
      const rs = state.roundTimer.remaining % 60;
      roundTimeDisplay.textContent = `${rm}:${rs.toString().padStart(2, "0")}`;

      if (state.roundTimer.remaining <= 0 && state.animation.checkWin) {

        stopAllTimers();
        state.animation.running = false;

        state.score.CT++;
        updateScoreDisplay();

        if (state.currentTeam === "CT") {
          alert("Your team wins!");
        } else {
          alert("Enemy team wins!");
        }

        return;
      }
    }


    // ---------------------------------------------------------
    // DEFUSE CHECK (nur EIN CT darf defusen)
    // ---------------------------------------------------------
    if (state.bomb.planted) {

      const ctTeamIsEnemy = (state.currentTeam === "T");
      const CTs = state.animation.players.filter(
        p => p.alive && (p.isEnemy === ctTeamIsEnemy)
      );

      // Falls aktueller Defuser tot â†’ freigeben
      if (state.bomb.defuser && !state.bomb.defuser.alive) {
        state.bomb.defuser = null;
      }

      // Falls kein Defuser â†’ CT auswÃ¤hlen, der auf Bombe steht
      if (!state.bomb.defuser) {
        for (const ct of CTs) {
          const dx = ct.x - state.bomb.x;
          const dy = ct.y - state.bomb.y;
          const dist = Math.sqrt(dx*dx + dy*dy);

          if (dist < 12) {
            state.bomb.defuser = ct;
            ct.defuseRemaining = 5;
            break;
          }
        }
      }

      // Wenn es einen Defuser gibt â†’ Timer runterzÃ¤hlen
      if (state.bomb.defuser) {
        state.bomb.defuser.defuseRemaining -= 1;

        if (state.bomb.defuser.defuseRemaining <= 0) {

          stopAllTimers();
          state.animation.running = false;

          state.bomb.planted = false;
          state.bomb.timer = 40;
          state.bomb.defuser = null;

          state.score.CT++;
          updateScoreDisplay();

          if (state.currentTeam === "CT") {
            alert("Your team wins!");
          } else {
            alert("Enemy team wins!");
          }

          return;
        }
      }
    }


    // ---------------------------------------------------------
    // BOMB TIMER (Explosion)
    // ---------------------------------------------------------
    if (state.bomb.planted) {

      state.bomb.timer--;

      const bs = state.bomb.timer;
      roundTimeDisplay.textContent = `0:${bs.toString().padStart(2, "0")}`;

      if (bs <= 0) {

        stopAllTimers();
        state.animation.running = false;

        const myTeam = state.currentTeam;

        if (myTeam === "T") {
          state.score.T++;
          updateScoreDisplay();
          alert("Your team wins!");
        } else {
          state.score.T++;
          updateScoreDisplay();
          alert("Enemy team wins!");
        }

        return;
      }
    }

  }, 1000);
}

function stopAllTimers() {
  // Round timer
  if (state.roundTimer.interval) {
    clearInterval(state.roundTimer.interval);
    state.roundTimer.interval = null;
  }

  // Duration timer
  if (state.durationTimer.interval) {
    clearInterval(state.durationTimer.interval);
    state.durationTimer.interval = null;
  }

  // Duration pre-countdown
  if (state.durationTimer.preCountdown) {
    clearInterval(state.durationTimer.preCountdown);
    state.durationTimer.preCountdown = null;
  }

  // Round pre-countdown
  if (state.roundTimer.interval) {
    clearInterval(state.roundTimer.interval);
    state.roundTimer.interval = null;
  }

  // Unified tick
  if (state.unifiedInterval) {
    clearInterval(state.unifiedInterval);
    state.unifiedInterval = null;
  }

  // Bomb timer
  if (state.bomb.interval) {
    clearInterval(state.bomb.interval);
    state.bomb.interval = null;
  }
}

/* -------------------------------------------------------
   PLAY / STOP / PAUSE BUTTONS
------------------------------------------------------- */

btnPlay.addEventListener('click', () => {
  state.animation.checkWin = false;

  stopAnimation();
  resetRoundTimer();

state.lastEnemyTacticName = "";
updateTacticInfoDisplay();

startAnimation();
startDurationTimer();
});

// -------------------------------------------------------
// SIMULATE VS RANDOM ENEMY
// -------------------------------------------------------
btnPlayVs.addEventListener('click', () => {
  state.animation.checkWin = true;

  stopAnimation();
  resetRoundTimer();
  state.paused = false;

  const map = state.currentMap;
  const myTeam = state.currentTeam;
  const enemyTeam = myTeam === "T" ? "CT" : "T";

  const enemyTab = state.tabs[map][enemyTeam];
  const enemyTactics = Object.keys(enemyTab.savedTactics);

  if (enemyTactics.length === 0) {
    alert("No enemy tactics found for this map.\nCreate a tactic for the other team on this map.");
    return;
  }

  // Mask fÃ¼r aktuelle Map laden, dann erst starten
  loadMaskForMap(map, () => {
buildWalkabilityGrid();
    // Random enemy tactic
    const randomName = enemyTactics[Math.floor(Math.random() * enemyTactics.length)];
state.lastEnemyTacticName = randomName;
updateTacticInfoDisplay();
    const randomTactic = enemyTab.savedTactics[randomName];

    // Build animation state for both teams
    const myAnim = buildAnimationState();
    const enemyAnim = buildEnemyAnimationState(randomTactic.players);

    // Init animation state
    state.animation.players = [...myAnim, ...enemyAnim];
    state.animation.grenades = [];
    state.animation.running = false;
    state.animation.lastTime = null;
    state.animation.frameRequest = null;
    state.animation.shootAccumulator = 0;

    // Clear bottom layer and render both teams
    playersLayerBottom.innerHTML = '';

    state.animation.players.forEach(p => {
      const el = document.createElement('div');
      el.className = 'player-bottom';
      el.style.backgroundColor = p.color;
      el.style.left = p.x + 'px';
      el.style.top = p.y + 'px';

      // Enemy outline
      if (p.isEnemy) {
        el.style.border = "1px solid #ff4444";
      }

      playersLayerBottom.appendChild(el);
      p.el = el;
    });

    state.animation.running = true;
state.animation.lastTime = null;
state.animation.frameRequest = requestAnimationFrame(animationLoop);

startDurationTimer();
  });
});

btnStop.addEventListener('click', () => {
  stopAnimation();
  resetRoundTimer();

// Stop bomb timer
if (state.bomb.interval) {
  clearInterval(state.bomb.interval);
  state.bomb.interval = null;
}
state.bomb.planted = false;
state.bomb.timer = 40;
});

btnPause.addEventListener('click', () => {
  state.paused = !state.paused;

  if (state.paused) {
    // Animation pausieren
    if (state.animation.frameRequest) {
      cancelAnimationFrame(state.animation.frameRequest);
      state.animation.frameRequest = null;
    }

    // Round timer pausieren
    if (state.roundTimer.interval) {
      clearInterval(state.roundTimer.interval);
      state.roundTimer.interval = null;
    }

    // Unified tick pausieren
    if (state.unifiedInterval) {
      clearInterval(state.unifiedInterval);
      state.unifiedInterval = null;
    }

  } else {
    // Animation fortsetzen
    state.animation.lastTime = null;
    state.animation.frameRequest = requestAnimationFrame(animationLoop);

    // Wenn Bombe liegt â†’ unified tick starten
    if (state.bomb.planted) {
      startUnifiedTick();
    } else {
      // Sonst normalen Round Timer starten
      if (state.roundTimer.remaining > 0) {
      }

      // Duration Timer starten
      startDurationTimer();
    }
  }
});

/* -------------------------------------------------------
   MENU BUTTONS
------------------------------------------------------- */

// Export Playbook
btnExportPlaybook.addEventListener('click', () => {
  const data = JSON.stringify(state.tabs, null, 2);

  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "mycs2playbook.json";
  a.click();

  URL.revokeObjectURL(url);
});

// Import playbook
btnImportPlaybook.addEventListener('click', () => {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".json";

  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const imported = JSON.parse(ev.target.result);

        // Merge imported maps into existing state
        for (const mapName in imported) {
          state.tabs[mapName] = imported[mapName];
        }

        // Clear history for all maps/teams
        Object.values(state.tabs).forEach(map =>
          Object.values(map).forEach(teamTab => teamTab.history = [])
        );

        renderTabs();
        renderCurrentTab();

        // ---------------------------------------------
        // Count all imported tactics
        // ---------------------------------------------
        let tacticCount = 0;
        for (const mapName in state.tabs) {
          for (const teamName in state.tabs[mapName]) {
            const teamTab = state.tabs[mapName][teamName];
            if (teamTab.savedTactics) {
              tacticCount += Object.keys(teamTab.savedTactics).length;
            }
          }
        }

        alert(
          "Playbook successfully imported!\n" +
          tacticCount + " tactics found."
        );

      } catch (err) {
        alert("Error importing the JSON file.");
      }
    };

    reader.readAsText(file);
  };

  input.click();
});

// Export tactic
btnExportTactic.addEventListener('click', () => {
  const tab = state.tabs[state.currentMap][state.currentTeam];
  const name = tab.currentTacticName;

  // If no saved tactic is chosen â†’ default export
  if (!name) {
    const data = JSON.stringify({
      players: tab.players,
      notes: tab.notes,
      stats: tab.stats,
      map: state.currentMap,
      team: state.currentTeam
    }, null, 2);

    const blob = new Blob([data], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "mycs2tactic.json";
    a.click();

    URL.revokeObjectURL(url);
    return;
  }

  // Export a named tactic
  const tactic = tab.savedTactics[name];
  if (!tactic) {
    alert("No tactic selected.");
    return;
  }

  const data = JSON.stringify({
    ...tactic,
    map: state.currentMap,
    team: state.currentTeam
  }, null, 2);

  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = `${name}.json`;
  a.click();

  URL.revokeObjectURL(url);
});

// Import tactic
btnImportTactic.addEventListener('click', () => {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".json";

  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const imported = JSON.parse(ev.target.result);

        // Validation
        if (!imported.players) {
          alert("Invalid tactic file (missing players).");
          return;
        }

        // Automatically fill in missing fields
        if (!imported.notes) imported.notes = "";
        if (!imported.stats) imported.stats = { wins: 0, losses: 0 };

        // Detect map & team (fallback: current tab)
        const map = imported.map || state.currentMap;
        const team = imported.team || state.currentTeam;

        // Default name = filename without .json
        let defaultName = file.name.replace(/\.json$/i, "");
        const name = prompt("Enter name for imported tactic:", defaultName);
        if (!name) return;

        // Categorize tactic
        const tab = state.tabs[map][team];
        tab.savedTactics[name] = imported;
        tab.currentTacticName = name;

        renderSavedTactics();
        renderCurrentTab();

        alert(
          "Tactic imported successfully!\n" +
          "Map: " + map + " | Team: " + (team === "T" ? "Terrorists" : "Counterâ€‘Terrorists")
        );

      } catch (err) {
        alert("Error importing tactic file:\n" + err.message);
      }
    };

    reader.readAsText(file);
  };

  input.click();
});

btnNew.addEventListener('click', () => {
  const tab = state.tabs[state.currentMap][state.currentTeam];

  // Deselect current tactic
  tab.currentTacticName = null;

  // Snapshot before reset
  pushHistorySnapshot(state.currentMap, state.currentTeam);

  // Reset tab
  resetTab(state.currentMap, state.currentTeam, false);

  // Refresh UI
  renderSavedTactics();
  renderCurrentTab();
});

btnSave.addEventListener('click', () => {
  saveCurrentTactic();
});

btnDelete.addEventListener('click', () => {
  deleteCurrentTactic();
});

btnUndo.addEventListener('click', () => {
  undoCurrentTab();
});

// Statistics buttons
document.getElementById("btnWin").addEventListener("click", () => {
  const tab = state.tabs[state.currentMap][state.currentTeam];
  tab.stats.wins++;

  if (tab.currentTacticName) {
    tab.savedTactics[tab.currentTacticName].stats = tab.stats;
  }

  renderStats();
});

document.getElementById("btnLoss").addEventListener("click", () => {
  const tab = state.tabs[state.currentMap][state.currentTeam];
  tab.stats.losses++;

  if (tab.currentTacticName) {
    tab.savedTactics[tab.currentTacticName].stats = tab.stats;
  }

  renderStats();
});

// --- Round won (-) ---
document.getElementById("btnWinMinus").addEventListener("click", () => {
  const tab = state.tabs[state.currentMap][state.currentTeam];

  if (tab.stats.wins > 0) {
    tab.stats.wins--;
  }

  if (tab.currentTacticName) {
    tab.savedTactics[tab.currentTacticName].stats = tab.stats;
  }

  renderStats();
});

// --- Round lost (-) ---
document.getElementById("btnLossMinus").addEventListener("click", () => {
  const tab = state.tabs[state.currentMap][state.currentTeam];

  if (tab.stats.losses > 0) {
    tab.stats.losses--;
  }

  if (tab.currentTacticName) {
    tab.savedTactics[tab.currentTacticName].stats = tab.stats;
  }

  renderStats();
});

/* -------------------------------------------------------
   GLOBAL CLICK (CLOSE MENU)
------------------------------------------------------- */

document.addEventListener('click', () => {
  hidePlayerMenu();
});

overviewTopImg.addEventListener('click', (e) => {
  if (!state.currentAction) return;

  const rect = overviewTopImg.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  /* -------------------------------------------------------
     GRENADE
  ------------------------------------------------------- */
  if (state.currentAction === 'Grenade' && state.pendingGrenadePlayer) {
    const player = state.pendingGrenadePlayer;

    pushHistorySnapshot(state.currentMap, state.currentTeam);

    player.paths.push({
      type: 'Grenade',
      from: { x: player.x, y: player.y },
      to: { x, y }
    });

    state.pendingGrenadePlayer = null;
    state.currentAction = null;
    renderPlayersAndPaths();
    return;
  }

/* -------------------------------------------------------
     FLASHBANG
  ------------------------------------------------------- */
  if (state.currentAction === 'Flashbang' && state.pendingFlashPlayer) {
    const player = state.pendingFlashPlayer;

    pushHistorySnapshot(state.currentMap, state.currentTeam);

    player.paths.push({
      type: 'Flashbang',
      from: { x: player.x, y: player.y },
      to: { x, y }
    });

    state.pendingFlashPlayer = null;
    state.currentAction = null;
    renderPlayersAndPaths();
    return;
  }

  /* -------------------------------------------------------
     SMOKE
  ------------------------------------------------------- */
  if (state.currentAction === 'Smoke' && state.pendingSmokePlayer) {
    const player = state.pendingSmokePlayer;

    pushHistorySnapshot(state.currentMap, state.currentTeam);

    player.paths.push({
      type: 'Smoke',
      from: { x: player.x, y: player.y },
      to: { x, y }
    });

    state.pendingSmokePlayer = null;
    state.currentAction = null;
    renderPlayersAndPaths();
    return;
  }

  /* -------------------------------------------------------
     MOLOTOV
  ------------------------------------------------------- */
  if (state.currentAction === 'Molotov' && state.pendingMolotovPlayer) {
    const player = state.pendingMolotovPlayer;

    pushHistorySnapshot(state.currentMap, state.currentTeam);

    player.paths.push({
      type: 'Molotov',
      from: { x: player.x, y: player.y },
      to: { x, y }
    });

    state.pendingMolotovPlayer = null;
    state.currentAction = null;
    renderPlayersAndPaths();
    return;
  }

  /* -------------------------------------------------------
     TELEPORT
  ------------------------------------------------------- */
  if (state.currentAction === 'Teleport' && state.pendingTeleportPlayer) {
    const player = state.pendingTeleportPlayer;

    pushHistorySnapshot(state.currentMap, state.currentTeam);

    player.paths.push({
      type: 'Teleport',
      from: { x: player.x, y: player.y },
      to: { x, y }
    });

    // Spieler sofort versetzen
    player.x = x;
    player.y = y;

    state.pendingTeleportPlayer = null;
    state.currentAction = null;
    renderPlayersAndPaths();
    return;
  }
});

/* -------------------------------------------------------
   START
------------------------------------------------------- */

initState();
initTabsUI();
renderCurrentTab();

// Warn user before closing the tab or browser window
window.addEventListener("beforeunload", (e) => {
  e.preventDefault();
  e.returnValue = ""; // Required for Chrome, Firefox, Edge
});
</script>
</body>
</html>